| Лабораторная работа №3   | M3202                  | АОВС |
| ------------------------ |------------------------| ---- |
| Кэш и кодирование команд | Мурадян Арам Суренович | 2024 |


## Инструментарий
Работа выполнена на C++20 и с помощью архитектуры набора команд
RISC-V


## Что реализовано
- вариант 3
- lite версия
- Выполнен перевод кода из C на ассемблер
- Выполнена политика вытеснения LRU и bit-pLRU
- Не выполнен перевод в машинный код

# Описание:

## ISA:

### Перевод из C в asm RISC-V
Для решения этой задачи потребовались следующие инструкции и знания:
1) ADDI t0, t1, x - записывает в регистр t0 сумму числа x и числа из регистра t1. Причем от числа x берутся только младшие 12 бит.
2) ADD t0, t1, t2 - записывает в регистр t0 сумму чисел из регистров t1 и t2.
3) SLLI t0, t1, x - записывает в регистр t0 число из регистра t1, сдвинутое влево побитово на x.
4) LB t0, x, t1 - записывает в регистр t0 BYTE (8 бит) из адреса, который высчитывается как сумма числа x и числа из регистра t1
5) LH t0, x, t1 - записывает в регистр t0 HALF (16 бит) из адреса, который высчитывается как сумма числа x и числа из регистра t1
6) BLT t0, t1, x - прибавляет к PC число x, если t0 < t1.
7) SW t0, x, t1 - записывает по адресу, который высчитывается как сумма числа x и числа из регистра t1 WORD (32 бита) из регистра t0
8) JALR  t0, ra, 0 - устанавливает точку возврата
9) Каждая инструкция кодируется 4 байтами
10) PC - указывает, какая инструкция должна быть выполнена следующей.
11) Регистр zero всегда возвращает 0.

Все локальные переменные хранились в регистрах. С помощью инструкции ADDI t0, zero, x можно было установить значение x в регистры. Если число превышало 2047, то с помощью SLLI записывались сначала старшие биты числа x и сдвигались.

Цикл реализовывался с помощью помещения значения 0 в некоторый регистр t0, инструкции BLT, которая переставляла PC на начало цикла, и с помощью инкрементирования значения в регистре, которое отвечало за счетчик цикла (ADDI t0, t0, 1). Операнд инструкции BLT, отвечающий за прибавление некоторого числа к PC высчитывался как 4 * кол-во инструкций до начала цикла, т.к. каждая инструкция кодируется 4 байтами.

По условию ТЗ массивы хранятся в памяти последовательно, начиная с адреса 0x100. Зная адрес начала массива a и размерности массивов b, c, можно посчитать начала адресов массивов b и с. В массиве a всего M*K элементов по 1 байту каждый. Поэтому массив b начинается с адреса 0x100 + 64 * 32 * 1 = 2304. Массив c - с адреса 2304 + 60 * 32 * 2 = 6144. Так же важно было учесть размеры элементов массивов b, c при переводе следующих строк:  
pa += K;  
pc += N;  
s += pa[k] * pb[x];  
pb += N;

### Транслятор asm->binary
Не реализован


## Cache:

### Результат расчёта параметров системы
По условию ADDR_LEN = 18 бит, значит MEM_SIZE = 2^18 = 262144 байт  
По условию CACHE_INDEX_LEN = 3 бита, значит CACHE_SETS = 2^3 = 8  
CACHE_WAY = CACHE_LINE_COUNT / CACHE_SETS = 4 (На каждый уходит одинаковое количество кэш-линий)  
CACHE_SIZE = CACHE_LINE_COUNT * CACHE_LINE_SIZE = 2048 байт  
CACHE_TAG_LEN = ADDR_LEN - log2_(CACHE_LINE_SIZE * CACHE_SETS) = 18 - log2_2^9 = 18 - 9 = 9. Пояснение: CACHE_LINE_SIZE * CACHE_SETS - это количество байт, которое занимает один блок RAM. Чтобы определить, какой конкретно адрес у блока в RAM, из которого идет отображение на кэш-линию, нам не понадобятся младшие 9 бит адреса, но понадобятся оставшиеся старшие биты - их мы и записываем в TAG.  
CACHE_OFFSET_LEN = ADDR_LEN - CACHE_TAG_LEN - CACHE_INDEX_LEN = 18 - 9 - 3 = 6 бит. Это следует из условия, в котором сказано, что адрес состоит из tag, index, offset.

MEM_SIZE = 262144 байт  
ADDR_LEN = 18 бит  
CACHE_WAY = 4  
CACHE_TAG_LEN = 9 бит  
CACHE_INDEX_LEN = 3 бита  
CACHE_OFFSET_LEN = 6 битов  
CACHE_SIZE = 2048 байт  
CACHE_LINE_SIZE = 64 байт  
CACHE_LINE_COUNT = 32  
CACHE_SETS = 8

### Классы и функции для представления кэша

#### class CacheLRU
Структура: CacheLRU хранил массив из CacheWay. CacheWay - класс, который не имел методов и хранил в себе массив из CacheLine.

Когда на вход поступала одна из инструкции LB, LH, LW, SB, SH, SW, счетчик обращений к кэшу увеличивался на 1. Затем адрес разбивался на index, tag, offset в соответствии с условием. Через метод GetCacheSetInfo(index, tag) собиралась необходимая информация о текущем состояний кэш-линий с соответствующим индексом - есть ли кэш-линия с запрашиваемым тэгом и, если таковой нет, то какую кэш-линию надо вытеснить. Для реализации такой политики вытеснения в классе CacheLine определено поле last_used. Каждый раз, когда у кэш линии запрашивается одна из вышеописанных инструкций, в поле помещается значение, равное коли-ву обращений к кэшу.  
Если произошло попадание, тогда счетчик попаданий увеличивается на 1 и у соответствующей CacheLine вызывается соответствующий метод - LoadByte, LoadWord, ...  
Иначе кэш-линия, которая не использовалась дольше всех (мы ее уже определили) вытесняется из кэша и на ее место загружается новая.  
Метод CopyCacheLineInMemory(cache_way_index, index, tag) восстанавливает адрес памяти, которому соответствует кэш-линия, которая подлежит вытеснению, и записывает по этому адресу все данные из кэш-линии.  
Метод CopyMemoryInCacheLine(cache_way_index, index, tag) восстанавливает адрес памяти, по которому необходимо взять данные, и загружает их в новую кэш-линию.  
Методы CopyCacheLineInMemory и CopyMemoryInCacheLine последовательно вызываются. Теперь, когда нужная кэш-линия загружена, у нее вызывается соответствующий метод LoadByte, LoadWord, ...

#### class CachePLRU
Перечислим отличия от CacheLRU.  
В поле класса CacheLine вместо поля, отвечающего за время, стоит поле bool mru_bit.  
Функция GetCacheSetInfo(), если не нашлось кэш-линии с нужным тегом, теперь определяет на вытеснение первую кэш-линию, у которой mru_bit = false.  
Когда на вход поступала одна из инструкции LB, LH, LW, SB, SH, SW, после выполнения всех операции, которые бы были выполнены в CacheLRU (здесь они выполняются так же), вызывается метод SetZeroCacheLines(index, exception). Этот метод проверяет, не случилось ли так, что у всех кэш-линий с индексом index поле mru_bit = true, и если так случилось, то выставляет у всех кэш-линий с заданным index mru_bit = false, за исключением кэш-линии, с которой происходила работа (exception).  
В остальном работа аналогична.


## Моделирование задачи:
Аргументы: --replacement 0 --asm rv32.asm  
Вывод:  
LRU     hit rate: 80.7821%  
pLRU    hit rate: 86.3902%

### Теория устройства кэша
Моделируемый кэш является наборно ассоциативным. Он состоит из мини-кэшей. Каждый мини-кэш состоит из кэш-линий. У кэш-линий есть свой индекс. Кэш-линии с одинаковым индексом образуют множество.  
RAM разбивается на блоки, равные по размеру мини-кэшам (без учета служебной информации). Каждый блок так же разбивается на кэш-линии. Теперь RAM как бы тоже состоит из мини-кэшей. Зная все размерности, по некоторому адресу памяти можно однозначно определить, какому блоку этот адрес принадлежит и в какой кэш-линии лежит. TAG - это некоторые n старших битов адреса, которые однозначно помогают понять, какому блоку принадлежит адрес. Размер TAG не равен размеру всего адреса. Если размер адреса N, то младшие N - n битов адреса отвечают за то, под каким индексом лежит множество кэш-линии, в которые может быть отображена кэш-линия RAM. Рассмотрим произвольную кэш-линию из RAM, которая имеет индекс x. Тогда она может быть отображена в любую кэш-линию из множества под индексом x. Таким образом, данный кэш сочетает в себе и Direct Mapping и Associative Mapping.
### Политика вытеснения LRU
Для быстрой работы LRU может использоваться структура данных приоритетная очередь, но в данной работе она не использовалась ввиду слишком маленького количества мини-кэшей. 
 

